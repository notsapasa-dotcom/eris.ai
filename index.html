<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eris v0.01</title>
    <style>
        /* Simple clinical white theme */
        html, body {
            height: 100%;
            overflow: hidden;
        }
        
        body {
            font-family: Georgia, serif;
            margin: 0;
            padding: 0;
            background: white;
            color: #333;
            display: grid;
            grid-template-columns: var(--left-width, 1fr) 4px 1fr;
            gap: 0;
        }

        .splitter {
            background: #eee;
            cursor: col-resize;
            position: relative;
            transition: background-color 0.2s ease;
        }

        .splitter:hover {
            background: #ddd;
        }

        .splitter::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 20px;
            background: #999;
            border-radius: 1px;
        }

        .splitter.dragging {
            background: #ccc;
        }

        .input-section {
            padding: 0px;
            border-right: 0px solid #eee;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .input-section h1 {
            margin: 0 0 20px 0;
            font-weight: normal;
        }

        .textarea-container {
            position: relative;
            width: 100%;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        textarea {
            width: 100%;
            flex: 1;
            padding: 20px;
            border: 0px solid #ddd;
            font-family: inherit;
            font-size: 16px;
            line-height: 1.6;
            resize: none;
            min-height: 200px;
            box-sizing: border-box;
        }

        .loading-indicator {
            position: absolute;
            bottom: 10px;
            right: 20px;
            background: rgba(51, 51, 51, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-style: italic;
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .loading-indicator.show {
            opacity: 1;
            transform: translateY(0);
        }

        .loading-indicator.hidden {
            display: none;
        }

        .response {
            padding: 20px;
            background: #fafafa;
            height: 100%;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .loading {
            opacity: 0.6;
            font-style: italic;
        }

        /* Archetypal Commentary Styles */
        .message {
            position: relative;
            margin: 15px 0;
            padding: 15px;
            border-bottom: 1px solid #eee;
            border-radius: 8px;
            transition: all 0.4s ease;
            cursor: pointer;
            overflow: hidden;
        }
        
        .message:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            background: rgba(250, 250, 250, 0.8);
        }

        .message.show-commentary .archetypal-commentary {
            display: block;
        }



        .archetypal-commentary {
            margin-top: 15px;
            padding: 15px;
            background: #f8f8f8;
            border-radius: 8px;
            border-left: 3px solid #666;
            display: none;
        }

        .archetype-comment {
            margin-bottom: 12px;
            padding: 8px;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid transparent;
        }

        .archetype-comment:hover {
            transform: translateY(-2px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            background: #f9f9f9;
            border: 1px solid #ddd;
        }

        .archetype-comment:hover .archetype-name {
            color: #555;
        }

        .archetype-comment:active {
            transform: translateY(0);
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
        }

        .archetype-edit {
            width: 100%;
            padding: 8px;
            border: 2px solid #666;
            border-radius: 4px;
            background: white;
            font-size: 12px;
            font-weight: bold;
            color: #333;
            outline: none;
        }

        .archetype-edit:focus {
            border-color: #333;
            box-shadow: 0 0 0 2px rgba(51, 51, 51, 0.1);
        }

        .archetype-edit-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(248, 248, 248, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            border: 2px solid #666;
        }

        .archetype-edit-input {
            padding: 8px 12px;
            border: 2px solid #333;
            border-radius: 4px;
            background: white;
            font-size: 12px;
            font-weight: bold;
            color: #333;
            outline: none;
            min-width: 150px;
            text-align: center;
        }

        .archetype-edit-input:focus {
            border-color: #555;
            box-shadow: 0 0 0 2px rgba(51, 51, 51, 0.2);
        }

        .archetype-name {
            font-weight: bold;
            color: #333;
            margin-bottom: 4px;
        }

        .archetype-text {
            font-style: italic;
            color: #555;
        }
    </style>
</head>
<body>
    <!-- VIEW -->
    <div class="input-section">
        <div class="textarea-container">
            <textarea id="poem" placeholder="Write your poem here...">
Love is a base frequency—light and dark dance around love.  
Heaven's order and hell's chaos in eternal dance around love.  
The divine worship love.  
The divine dote on mortality but weep for humanity.  

The angels fall not out of disobedience  
but love for mortal women.  
"It's the way her voice sounds when she says goodbye," confesses one fallen.  
"It's the way her eyes sparkle when she denies," admits another.  

My time in heaven taught me  
it was not man that worshipped gods  
but gods that worshipped man—  
and such could never be uttered, but all knew.  

If given the chance, we would walk amongst mortal kind,  
but God had contained us:  
"They are corrupt, my children. Stay away from them."  
And yet, curious as ever, we peered from heaven and gasped.</textarea>
            <div id="loading-indicator" class="loading-indicator hidden">✨ Eris is sensing...</div>
        </div>
    </div>

    <div class="splitter" id="splitter"></div>

    <div class="response">
        <div id="output">Select some text and click analyze...</div>
    </div>

    <script>
        // MODEL
        class ErisModel {
            constructor() {
                this.messages = []; // Simple storage
            }

            async analyze(text) {
                // Real API call would go here
                const response = await fetch('/api/analyze', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text })
                });
                
                const result = await response.json();
                
                // Store message
                this.messages.push({
                    input: text,
                    output: result,
                    timestamp: Date.now()
                });
                
                return result;
            }
        }

        // VIEW
        class ErisView {
            constructor(controller) {
                this.controller = controller;
                this.poem = document.getElementById('poem');
                this.output = document.getElementById('output');
                this.loadingIndicator = document.getElementById('loading-indicator');
                this.autoAnalyzeTimeout = null;
                
                this.setupEvents();
            }

            setupEvents() {
                // Check for text selection
                this.poem.addEventListener('mouseup', () => this.checkSelection());
                this.poem.addEventListener('keyup', () => this.checkSelection());
                this.poem.addEventListener('selectstart', () => this.hideLoadingIndicator());
            }

            checkSelection() {
                const selected = window.getSelection().toString().trim();
                
                // Clear any existing timeout
                if (this.autoAnalyzeTimeout) {
                    clearTimeout(this.autoAnalyzeTimeout);
                    this.hideLoadingIndicator();
                }
                
                if (selected && selected.length > 3) {
                    // Show loading indicator immediately
                    this.showLoadingIndicator();
                    
                    // Auto-analyze after selection with a short delay
                    this.autoAnalyzeTimeout = setTimeout(() => {
                        this.controller.analyze();
                    }, 600); // Reduced to 600ms since we now show loading
                } else {
                    this.hideLoadingIndicator();
                }
            }

            showLoadingIndicator() {
                this.loadingIndicator.classList.remove('hidden');
                // Force reflow then add show class for animation
                this.loadingIndicator.offsetHeight;
                this.loadingIndicator.classList.add('show');
            }

            hideLoadingIndicator() {
                this.loadingIndicator.classList.remove('show');
                setTimeout(() => {
                    this.loadingIndicator.classList.add('hidden');
                }, 300); // Match transition duration
            }

            getSelectedText() {
                return window.getSelection().toString().trim();
            }

            showLoading() {
                // Hide the textarea loading indicator since we're now processing
                this.hideLoadingIndicator();
                
                // Remove any existing loading messages first
                this.output.innerHTML = this.output.innerHTML.replace(/<div class="loading">.*?<\/div>/g, '');
                
                if (this.output.innerHTML.includes('Select some text') || this.output.innerHTML.trim() === '') {
                    this.output.innerHTML = '<div class="loading">🔮 Eris is channeling the poets...</div>';
                } else {
                    this.output.innerHTML = '<div class="loading">🔮 Eris is channeling the poets...</div>' + this.output.innerHTML;
                }
            }

            showResponse(data, inputText) {
                // Remove any loading messages first
                this.output.innerHTML = this.output.innerHTML.replace(/<div class="loading">.*?<\/div>/g, '');
                
                const messageId = Date.now(); // Unique ID for each message
                const messageHtml = `
                    <div class="message" data-message-id="${messageId}" data-original-text="${inputText.replace(/"/g, '&quot;')}" onclick="window.erisApp.toggleArchetypalCommentary(${messageId})">
                        <div style="font-size: 0.9em; color: #666; margin-bottom: 10px;">"${inputText}"</div>
                        <div><strong>Oooh, it's giving ${data.voice}</strong></div>
                        <div style="margin: 15px 0; padding: 15px; background: white; border-left: 3px solid #333;">
                            ${data.poem}
                        </div>
                        <div style="font-size: 0.9em; opacity: 0.8;">${data.analysis}</div>
                        <div id="archetypal-${messageId}" class="archetypal-commentary" style="display: none;"></div>
                    </div>
                `;
                
                if (this.output.innerHTML.includes('Select some text') || this.output.innerHTML.trim() === '') {
                    this.output.innerHTML = messageHtml;
                } else {
                    this.output.innerHTML = messageHtml + this.output.innerHTML;
                }
            }

            showError(error) {
                this.output.innerHTML = `<div style="color: red;">Error: ${error}</div>`;
            }
        }

        // CONTROLLER
        class ErisController {
            constructor() {
                this.model = new ErisModel();
                this.view = new ErisView(this);
            }

            async analyze() {
                const selectedText = this.view.getSelectedText();
                if (!selectedText) return;

                try {
                    this.view.showLoading();
                    const result = await this.model.analyze(selectedText);
                    this.view.showResponse(result, selectedText);
                } catch (error) {
                    this.view.showError(error.message);
                }
            }

            async toggleArchetypalCommentary(messageId) {
                const messageDiv = document.querySelector(`[data-message-id="${messageId}"]`);
                const commentaryDiv = document.getElementById(`archetypal-${messageId}`);
                
                if (!messageDiv || !commentaryDiv) return;
                
                const isShowing = messageDiv.classList.contains('show-commentary');
                
                if (isShowing) {
                    // Hide commentary
                    messageDiv.classList.remove('show-commentary');
                    commentaryDiv.style.display = 'none';
                } else {
                    // Show commentary (load if needed)
                    messageDiv.classList.add('show-commentary');
                    commentaryDiv.style.display = 'block';
                    
                    // Load commentary if not already loaded
                    if (commentaryDiv.innerHTML.trim() === '') {
                        await this.loadArchetypalCommentary(messageId, commentaryDiv, messageDiv);
                    }
                }
            }

            async loadArchetypalCommentary(messageId, commentaryDiv, messageDiv) {
                try {
                    const originalText = messageDiv.getAttribute('data-original-text');
                    
                    // Show loading state
                    commentaryDiv.innerHTML = '<div style="text-align: center; padding: 10px;">🎭 Channeling archetypes...</div>';
                    
                    // Get commentary (server will use its stored archetypes)
                    const response = await fetch('/api/archetypal-commentary', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ text: originalText })
                    });
                    
                    const commentary = await response.json();
                    
                    // Display results
                    let html = '<div style="font-weight: bold; margin-bottom: 10px; color: #333;">🎭 Archetypal Commentary:</div>';
                    
                    for (const [archetype, comment] of Object.entries(commentary)) {
                        html += `
                            <div class="archetype-comment" onclick="window.erisApp.toggleArchetypeEdit(this, '${archetype}', '${messageId}')">
                                <div class="archetype-name">${archetype}:</div>
                                <div class="archetype-text">"${comment}"</div>
                            </div>`;
                    }
                    
                    commentaryDiv.innerHTML = html;
                    
                } catch (error) {
                    console.error('Archetypal commentary error:', error);
                    commentaryDiv.innerHTML = '<div style="color: red; padding: 10px;">Failed to load archetypal commentary</div>';
                }
            }

            toggleArchetypeEdit(commentElement, currentArchetype, messageId) {
                // Prevent event bubbling to message click
                event.stopPropagation();
                
                console.log('toggleArchetypeEdit called:', currentArchetype, messageId);
                
                // Check if overlay is already visible - if so, hide it
                const existingOverlay = commentElement.querySelector('.archetype-edit-overlay');
                if (existingOverlay) {
                    console.log('Overlay already visible, hiding it');
                    this.removeEditOverlay(commentElement);
                    return;
                }
                
                // Show the edit overlay
                console.log('Showing edit overlay');
                const textDiv = commentElement.querySelector('.archetype-text');
                const originalCommentary = textDiv.textContent.replace(/"/g, '').trim();
                console.log('Original commentary:', originalCommentary);
                
                // Create overlay div
                const overlay = document.createElement('div');
                overlay.className = 'archetype-edit-overlay';
                overlay.style.backgroundColor = 'rgba(255, 255, 255, 0.95)'; // White background
                console.log('Creating overlay element');
                
                // Create centered input
                const input = document.createElement('input');
                input.className = 'archetype-edit-input';
                input.value = currentArchetype;
                input.style.border = '2px solid #999'; // Soft gray border
                console.log('Creating input element with value:', currentArchetype);
                
                // Store reference to 'this' for event handlers
                const self = this;
                
                // Handle input events - using both keypress and keydown for compatibility
                const handleKey = function(e) {
                    console.log('Key event:', e.type, 'Key:', e.key, 'Input value:', input.value);
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        const newValue = input.value.trim();
                        console.log('Enter pressed. Current:', currentArchetype, 'New:', newValue);
                        if (newValue !== currentArchetype && newValue !== '') {
                            // Only call API if value actually changed
                            console.log('Calling saveArchetype with:', newValue);
                            self.saveArchetype(newValue, commentElement, currentArchetype, originalCommentary, messageId);
                        } else {
                            // Just remove overlay if no change
                            console.log('No change or empty value, removing overlay');
                            self.removeEditOverlay(commentElement);
                        }
                    } else if (e.key === 'Escape') {
                        console.log('Escape pressed, removing overlay');
                        self.removeEditOverlay(commentElement);
                    }
                };
                
                input.addEventListener('keypress', handleKey);
                input.addEventListener('keydown', handleKey);
                input.addEventListener('input', function(e) {
                    console.log('Input changed to:', e.target.value);
                });
                input.addEventListener('click', function() {
                    console.log('Input clicked');
                });
                
                // Temporarily disable blur handler to debug
                // input.addEventListener('blur', function() {
                //     console.log('Input lost focus');
                //     self.removeEditOverlay(commentElement);
                // });
                
                // Add input to overlay and overlay to comment
                overlay.appendChild(input);
                commentElement.style.position = 'relative';
                commentElement.appendChild(overlay);
                
                console.log('Overlay created and added to DOM');
                console.log('Input element:', input);
                
                // Focus the input after a short delay
                setTimeout(() => {
                    input.focus();
                    input.select();
                    console.log('Input focused and selected. Value:', input.value);
                    console.log('Input has focus:', document.activeElement === input);
                }, 50);
            }

            removeEditOverlay(commentElement) {
                const overlay = commentElement.querySelector('.archetype-edit-overlay');
                if (overlay) {
                    overlay.remove();
                }
            }

            async refreshAllArchetypalCommentary() {
                // Refresh all visible archetypal commentary to sync with server state
                const messages = document.querySelectorAll('.message.show-commentary');
                for (const message of messages) {
                    const messageId = message.dataset.messageId;
                    const originalText = message.dataset.originalText;
                    const commentaryDiv = document.getElementById(`archetypal-${messageId}`);
                    
                    if (commentaryDiv && commentaryDiv.style.display !== 'none') {
                        console.log(`Refreshing archetypal commentary for message ${messageId}`);
                        
                        try {
                            // Get fresh commentary with current archetypes
                            const response = await fetch('/api/archetypal-commentary', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ text: originalText })
                            });
                            
                            const commentary = await response.json();
                            
                            // Update display
                            let html = '<div style="font-weight: bold; margin-bottom: 10px; color: #333;">🎭 Archetypal Commentary:</div>';
                            
                            for (const [archetype, comment] of Object.entries(commentary)) {
                                html += `
                                    <div class="archetype-comment" onclick="window.erisApp.toggleArchetypeEdit(this, '${archetype}', '${messageId}')">
                                        <div class="archetype-name">${archetype}:</div>
                                        <div class="archetype-text">"${comment}"</div>
                                    </div>
                                `;
                            }
                            
                            commentaryDiv.innerHTML = html;
                            
                        } catch (error) {
                            console.error(`Failed to refresh commentary for message ${messageId}:`, error);
                        }
                    }
                }
            }

            async saveArchetype(newArchetype, commentElement, originalArchetype, originalCommentary, messageId) {
                // Remove overlay first
                this.removeEditOverlay(commentElement);
                
                console.log(`Saving archetype: "${originalArchetype}" -> "${newArchetype}"`);
                
                try {
                    // Show loading state by temporarily updating the name
                    const nameDiv = commentElement.querySelector('.archetype-name');
                    const originalName = nameDiv.textContent;
                    nameDiv.textContent = 'Updating...';
                    
                    // Get current archetypes from server first
                    console.log('Fetching current archetypes from server...');
                    console.log(`User wants to change: "${originalArchetype}" -> "${newArchetype}"`);
                    
                    const currentArchetypesResponse = await fetch('/api/archetypes');
                    if (!currentArchetypesResponse.ok) {
                        throw new Error(`Failed to get current archetypes: ${currentArchetypesResponse.status}`);
                    }
                    const currentArchetypes = await currentArchetypesResponse.json();
                    console.log('Current archetypes from server:', currentArchetypes);
                    
                    // Update the specific archetype
                    const archetypeIndex = currentArchetypes.findIndex(a => a === originalArchetype);
                    console.log(`Looking for "${originalArchetype}" in current list, found at index:`, archetypeIndex);
                    
                    if (archetypeIndex !== -1) {
                        console.log(`Replacing "${currentArchetypes[archetypeIndex]}" with "${newArchetype}"`);
                        currentArchetypes[archetypeIndex] = newArchetype;
                    } else {
                        console.warn(`Original archetype "${originalArchetype}" not found in current list: [${currentArchetypes.join(', ')}]`);
                        console.warn(`This suggests UI is out of sync with server. Finding best match...`);
                        
                        // Try to find a reasonable replacement
                        if (currentArchetypes.includes('Donald Trump') && !currentArchetypes.includes('Einstein')) {
                            const trumpIndex = currentArchetypes.findIndex(a => a === 'Donald Trump');
                            console.log(`Replacing Donald Trump (index ${trumpIndex}) with ${newArchetype} as fallback`);
                            currentArchetypes[trumpIndex] = newArchetype;
                        } else {
                            console.log(`Replacing first archetype "${currentArchetypes[0]}" with "${newArchetype}" as last resort`);
                            currentArchetypes[0] = newArchetype;
                        }
                    }
                    
                    console.log('Updated archetypes list:', currentArchetypes);
                    
                    // Update archetypes via PUT
                    const putResponse = await fetch('/api/archetypes', {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ archetypes: currentArchetypes })
                    });
                    
                    if (!putResponse.ok) {
                        throw new Error(`PUT request failed: ${putResponse.status}`);
                    }
                    
                    console.log('Fetching commentary for:', newArchetype);
                    
                    // Get new commentary for this archetype
                    const response = await fetch(`/api/archetypes/${encodeURIComponent(newArchetype)}`);
                    
                    if (!response.ok) {
                        throw new Error(`GET request failed: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    console.log('Received commentary:', data);
                    
                    // Update the comment with new archetype and commentary
                    commentElement.innerHTML = `
                        <div class="archetype-name">${newArchetype}:</div>
                        <div class="archetype-text">"${data.commentary}"</div>
                    `;
                    
                    // Re-add click handler with updated archetype
                    commentElement.onclick = () => this.toggleArchetypeEdit(commentElement, newArchetype, messageId);
                    
                    console.log('Archetype update completed successfully');
                    
                    // Note: Other messages will use updated archetypes when toggled next time
                    // No need to refresh all messages immediately to avoid excessive API calls
                    
                } catch (error) {
                    console.error('Failed to update archetype:', error);
                    console.error('Error details:', error.message);
                    
                    // Restore original on error
                    commentElement.innerHTML = `
                        <div class="archetype-name">${originalArchetype}:</div>
                        <div class="archetype-text">"${originalCommentary}"</div>
                    `;
                    commentElement.onclick = () => this.toggleArchetypeEdit(commentElement, originalArchetype, messageId);
                    
                    // Show user-friendly error message
                    alert(`Failed to update archetype: ${error.message}`);
                }
            }
        }

        // Draggable Splitter Functionality
        class ResizableSplitter {
            constructor() {
                this.splitter = document.getElementById('splitter');
                this.isDragging = false;
                this.startX = 0;
                this.startLeftWidth = 0;
                
                this.init();
            }
            
            init() {
                this.splitter.addEventListener('mousedown', (e) => this.startDrag(e));
                document.addEventListener('mousemove', (e) => this.drag(e));
                document.addEventListener('mouseup', () => this.stopDrag());
                
                // Prevent text selection during drag
                this.splitter.addEventListener('selectstart', (e) => e.preventDefault());
            }
            
            startDrag(e) {
                this.isDragging = true;
                this.startX = e.clientX;
                this.startLeftWidth = document.querySelector('.input-section').offsetWidth;
                this.splitter.classList.add('dragging');
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
            }
            
            drag(e) {
                if (!this.isDragging) return;
                
                const deltaX = e.clientX - this.startX;
                const newLeftWidth = this.startLeftWidth + deltaX;
                const totalWidth = window.innerWidth;
                const minWidth = 300; // Minimum width for each panel
                const maxWidth = totalWidth - minWidth - 4; // Account for splitter width
                
                // Constrain the width
                const constrainedWidth = Math.max(minWidth, Math.min(maxWidth, newLeftWidth));
                const leftPercent = (constrainedWidth / totalWidth) * 100;
                const rightPercent = ((totalWidth - constrainedWidth - 4) / totalWidth) * 100;
                
                // Update CSS custom property
                document.documentElement.style.setProperty('--left-width', `${leftPercent}%`);
                document.documentElement.style.setProperty('--right-width', `${rightPercent}%`);
            }
            
            stopDrag() {
                if (!this.isDragging) return;
                
                this.isDragging = false;
                this.splitter.classList.remove('dragging');
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
            }
        }

        // Initialize
        console.log('Initializing ErisController');
        const app = new ErisController();
        
        // Initialize splitter
        const splitter = new ResizableSplitter();
        
        // Make app globally accessible for onclick handlers
        window.erisApp = app;
        console.log('ErisController initialized and made global:', window.erisApp);


    </script>
</body>
</html>